!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	//
Assumption 0: There are no "speed" elevators. Each elevator goes to each floor	notes.md	/^## Assumption 0: There are no "speed" elevators. Each elevator goes to each floor$/;"	s
Assumption 1: There are no "up" or "down" request buttons. If an elevator is going up and 1 floor below an elevator is requested and there are no closer elevators then that elevator will reverse and pick up the person	notes.md	/^## Assumption 1: There are no "up" or "down" request buttons. If an elevator is going up and 1 f/;"	s
Assumption 2: The stops are determined by a que, if someone needs to go to a floor one above, then they need to wait till all the current people have gotten off. They might be waiting for a while. This logic could be changed in a 'sort fuction' but for now will be a que.	notes.md	/^## Assumption 2: The stops are determined by a que, if someone needs to go to a floor one above,/;"	s
Assumption 3: A "trip" is a stop. So each stop will count. Ie any time someone gets on or off will result in 1 trip. However people getting on and some getting off will count as 1 stop as well.	notes.md	/^## Assumption 3: A "trip" is a stop. So each stop will count. Ie any time someone gets on or off/;"	s
Assumption 4: At the end of a trip the elevator will stop in its place. It will not go to the top or bottom floor with no passengers. It will also not finish its "routes" once stopped. People will have to exit and try other elevators.	notes.md	/^## Assumption 4: At the end of a trip the elevator will stop in its place. It will not go to the/;"	s
Assumption 5: There is no limit to how many people can be in an elevator. This is unlike real life however the problem does not make this a requirement so I will ignore that case for now	notes.md	/^## Assumption 5: There is no limit to how many people can be in an elevator. This is unlike real/;"	s
Building	building.js	/^class Building {$/;"	c
Design decision 0: The system will be controlled via an event loop	notes.md	/^## Design decision 0: The system will be controlled via an event loop$/;"	s
Design decision 1: Each cycle an elevator will be able to move 1 floor.	notes.md	/^## Design decision 1: Each cycle an elevator will be able to move 1 floor.$/;"	s
Design decision 2: Each elevator can move to every floor	notes.md	/^## Design decision 2: Each elevator can move to every floor$/;"	s
Design decision 3: An elevator will take 2 "cycles" when it has reached a desired floor.	notes.md	/^## Design decision 3: An elevator will take 2 "cycles" when it has reached a desired floor.$/;"	s
Implementation 0 So elevators store a list of stop locations of their passengers. Check if the current floor matches any stops and then let those passengers with that stop get off. This will mean that each passenger will need to have a destination, however that will be added when they get on the elevator and only used to see if they should get off.	notes.md	/^## Implementation 0 So elevators store a list of stop locations of their passengers. Check if th/;"	s
Implementation 1: Each floor will be stored in a "building" each floor will be a list, and will contain the people wishing to get on an elevator, the people who got off the elevator and are done will not be stored. People who get off due to an elevator service stop will just get added to the floor list of people who's destination is another floor, the list of people wanting to get on an elevator.	notes.md	/^## Implementation 1: Each floor will be stored in a "building" each floor will be a list, and wi/;"	s
Implementation 2: The elevators and the floors will be stored in a "building" This way you can split up elevators and floors anyway you want. It would be possible to have the "speed" elevators from before by putting buildings inside of buildings. ie there are 4 "speed stops" in a building so each floor would be a "building" and have its own elevators. It is more extensible this way.	notes.md	/^## Implementation 2: The elevators and the floors will be stored in a "building" This way you ca/;"	s
Implementation 3: People will not store their location. Their location will be based on where they are. This will allow for only 1 "point of truth" so there cannot be an instance of someone being in 2 places at once.	notes.md	/^## Implementation 3: People will not store their location. Their location will be based on where/;"	s
Implementation 4: each building will have a list of elevators, called "shafts" that will store the elevator objects.	notes.md	/^## Implementation 4: each building will have a list of elevators, called "shafts" that will stor/;"	s
Implementation 5: each elevator will store a list of people that are inside the elevator.	notes.md	/^## Implementation 5: each elevator will store a list of people that are inside the elevator.$/;"	s
Implementation flaw 1:	notes.md	/^## Implementation flaw 1:$/;"	s
Person	person.js	/^class Person {$/;"	c
addDestination	elevator.js	/^  addDestination(destination){$/;"	m	class:elevator
addPassenger	elevator.js	/^  addPassenger(passenger){$/;"	m	class:elevator
addPassengersForFloor	elevator.js	/^  addPassengersForFloor(people){$/;"	m	class:elevator
addPeopleDestinationsToElevators	building.js	/^  addPeopleDestinationsToElevators(building){$/;"	m	class:Building
addPerson	floor.js	/^  addPerson(floor){$/;"	m	class:floor
addPickup	elevator.js	/^  addPickup(floor){$/;"	m	class:elevator
atDestination	elevator.js	/^  atDestination(){$/;"	m	class:elevator
betweenFloors	elevator.js	/^  betweenFloors(floor){$/;"	m	class:elevator
constructor	building.js	/^  constructor(id, floors, shafts){$/;"	m	class:Building
constructor	elevator.js	/^  constructor(id){$/;"	m	class:elevator
constructor	eventloop.js	/^  constructor(id, floors, shafts){$/;"	m	class:eventLoop
constructor	floor.js	/^  constructor(id, floorNumber){$/;"	m	class:floor
constructor	person.js	/^  constructor(id, desiredFloor){$/;"	m	class:Person
dropOffOrMove	eventloop.js	/^  dropOffOrMove(elevator){$/;"	m	class:eventLoop
elevator	elevator.js	/^class elevator {$/;"	c
eventLoop	eventloop.js	/^class eventLoop {$/;"	c
floor	floor.js	/^class floor {$/;"	c
getNumberOfFloors	building.js	/^  getNumberOfFloors(){$/;"	m	class:Building
getNumberOfShafts	building.js	/^  getNumberOfShafts(){$/;"	m	class:Building
next	eventloop.js	/^  next(){$/;"	m	class:eventLoop
onTheWay	elevator.js	/^  onTheWay(floor){$/;"	m	class:elevator
people	floor.js	/^  people(){$/;"	m	class:floor
removePassengersForFloor	elevator.js	/^  removePassengersForFloor(floor){$/;"	m	class:elevator
